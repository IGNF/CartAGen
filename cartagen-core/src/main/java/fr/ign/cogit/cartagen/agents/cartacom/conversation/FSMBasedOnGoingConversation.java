package fr.ign.cogit.cartagen.agents.cartacom.conversation;

import fr.ign.cogit.cartagen.agents.cartacom.agent.ConversationalObject;
import fr.ign.cogit.cartagen.agents.cartacom.agent.FSMBasedConversationalObject;
import fr.ign.cogit.cartagen.agents.core.task.Task;
import fr.ign.cogit.cartagen.agents.core.task.TaskStatus;
import fr.ign.cogit.cartagen.agents.core.task.TaskWithinConversation;

/**
 * Implementation of the interface {@link OnGoingConversation} for
 * {@link FSMBasedConversationalObject} : describes a conversation to which a
 * {@link FSMBasedConversationalObject} is taking part into, from its point of
 * view. It refers to a <code>ConversationState</code> of a
 * {@link HalfConversationScenario} , which dynamically changes as the
 * conversation progresses.
 * <p>
 * Its <code>conversationId</code> is NOT a unique identifier on the
 * <code> OnGoingConversation</code> class: the <code>OnGoingConversation</code>
 * describing the same conversation from the point of view of the
 * <code>partner </code> has the same <code>conversationId</code>.
 * @author CDuchene
 */
public class FSMBasedOnGoingConversation implements OnGoingConversation {

  // All static fields //

  // Public fields //

  // Protected fields //

  // Package visible fields //

  // Private fields with public getters //
  /**
   * An identifier for this on-going conversation, that is shared with the
   * on-going conversation describing the same conversation from the point of
   * view of the partner.
   */
  private long conversationId;
  /**
   * The partner of the FSM-based conversational object in this on-going
   * conversation.
   */
  private FSMBasedConversationalObject partner = null;
  /**
   * The state of the <code>HalfConversationScenario</code> this conversation is
   * following, that corresponds to the current state of this conversation.
   */
  private ConversationState referenceConversationState = null;
  /**
   * The task that has generated this conversation, if any (bidirectional
   * reference, automatically managed).
   */
  private Task dependentTask = null;
  /**
   * The task that has been generated by this conversation, if any
   * (bidirectional reference, automatically managed).
   */
  private TaskWithinConversation generatedTask = null;

  // Very private fields (no public getter) //

  // //////////////////////////////////////////
  // Static methods //
  // //////////////////////////////////////////

  // //////////////////////////////////////////
  // Public methods //
  // //////////////////////////////////////////

  // Public constructors //

  /**
   * For an conversational object, to construct an on-going conversation as
   * initiator (see {@link HalfConversationScenario#describedRole}), within a
   * task (that becomes dependent on the conversation). The constructor assigns
   * a conversationId to the new conversation, which can then be passed to the
   * partner within the first message sent.
   * @param partner the conversational object with which this conversation takes
   *          place
   * @param dependentTask the task that generates this conversation. Can be
   *          {@code null} (if the conversation is not generated within a task
   *          but e.g. directly in the main behaviour of the conversational
   *          object).
   * @param referenceConversationState the initial state of the conversation
   *          scenario this on-going conversation is following
   */
  public FSMBasedOnGoingConversation(ConversationalObject partner,
      Task dependentTask, ConversationState referenceInitialState) {
    this.conversationId = ConversationsManager.getInstance()
        .getNewConversationId();
    this.partner = (FSMBasedConversationalObject) partner;
    this.dependentTask = dependentTask;
    this.referenceConversationState = referenceInitialState;
  }

  /**
   * To construct an on-going conversation as a respondent (see
   * {@link HalfConversationScenario#describedRole}), i.e. after receiving a
   * message. The conversationId to assign to the conversation and the partner
   * are known from the received message, and the reference conversation state
   * can be deduced from it.
   * @param conversationId the conversationId to assign to the conversation
   * @param partner the conversational object with which this conversation takes
   *          place
   * @param referenceInitialState the initial state of the conversation scenario
   *          this on-going conversation is following
   */
  public FSMBasedOnGoingConversation(long conversationId,
      ConversationalObject partner, ConversationState referenceInitialState) {
    this.conversationId = conversationId;
    this.partner = (FSMBasedConversationalObject) partner;
    this.referenceConversationState = referenceInitialState;
  }

  // Public getters and setters //

  /**
   * Getter for conversationId.
   * @return the conversationId
   */
  @Override
  public long getConversationId() {
    return this.conversationId;
  }

  /**
   * Setter for conversationId.
   * @param conversationId the conversationId to set
   */
  @Override
  public void setConversationId(long conversationId) {
    this.conversationId = conversationId;
  }

  /**
   * Getter for partner.
   * @return the partner
   */
  @Override
  public ConversationalObject getPartner() {
    return this.partner;
  }

  /**
   * Setter for partner.
   * @param partner the partner to set
   */
  @Override
  public void setPartner(ConversationalObject partner) {
    this.partner = (FSMBasedConversationalObject) partner;
  }

  /**
   * Getter for referenceConversationState.
   * @return the referenceConversationState
   */
  public ConversationState getReferenceConversationState() {
    return this.referenceConversationState;
  }

  /**
   * Setter for referenceConversationState.
   * @param referenceConversationState the referenceConversationState to set
   */
  public void setReferenceConversationState(
      ConversationState referenceConversationState) {
    this.referenceConversationState = referenceConversationState;
  }

  /**
   * Getter for dependentTask. If no associated Task, returns null.
   * @return the dependentTask
   */
  @Override
  public Task getDependentTask() {
    return this.dependentTask;
  }

  /**
   * Setter for dependentTask. Also updates the reverse reference from
   * dependentTask to {@code this}. To break the reference use
   * {@code this.setDependentTask(null)}
   * @param dependentTask the dependentTask to set
   */
  @Override
  public void setDependentTask(Task dependentTask) {
    Task oldDependentTask = this.dependentTask;
    this.dependentTask = dependentTask;
    if (oldDependentTask != null) {
      oldDependentTask.getGeneratedConversations().remove(this);
    }
    if (dependentTask != null) {
      if (!dependentTask.getGeneratedConversations().contains(this)) {
        dependentTask.getGeneratedConversations().add(this);
      }
    }
  }

  /**
   * Getter for generatedTask. If no generated task, returns null.
   * @return the generatedTask
   */
  @Override
  public TaskWithinConversation getGeneratedTask() {
    return this.generatedTask;
  }

  /**
   * Setter for generatedTask. Also updates the reverse reference from
   * generatedTask to {@code this}. To break the reference use
   * {@code this.setGeneratedTask(null)}
   * @param generatedTask the generatedTask to set
   */
  @Override
  public void setGeneratedTask(TaskWithinConversation generatedTask) {
    TaskWithinConversation oldGeneratedTask = this.generatedTask;
    this.generatedTask = generatedTask;
    if (oldGeneratedTask != null) {
      oldGeneratedTask.setDependentConversation(null);
    }
    if (generatedTask != null) {
      if (generatedTask.getDependentConversation() != this) {
        generatedTask.setDependentConversation(this);
      }
    }
  }

  @Override
  public boolean isFinished() {
    if (this.getDependentTask() == null) {
      return false;
    }
    return this.getDependentTask().getStatus() == TaskStatus.FINISHED;
  }

  // Other public methods //

  // //////////////////////////////////////////
  // Protected methods //
  // //////////////////////////////////////////

  // //////////////////////////////////////////
  // Package visible methods //
  // //////////////////////////////////////////

  // ////////////////////////////////////////
  // Private methods //
  // ////////////////////////////////////////

}
