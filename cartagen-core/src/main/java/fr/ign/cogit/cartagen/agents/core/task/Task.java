/**
 * 
 */
package fr.ign.cogit.cartagen.agents.core.task;

import java.util.Set;

import fr.ign.cogit.cartagen.agents.cartacom.agent.ConversationalObject;
import fr.ign.cogit.cartagen.agents.cartacom.conversation.OnGoingConversation;

/**
 * A task encapsulates an action of a conversational object that can be on-going
 * or foreseen and that might need to be interrupted. A task can generate
 * conversations (the task is then dependent on these conversations). A task can
 * generate subtasks. Several tasks can also be grouped into an aggregated task
 * of which they become dependent. Finally, conversations can generate tasks.
 * Tasks that are possibly generated by a conversation are described by the more
 * specific interface TaskWithinConversation.
 * 
 * @author CDuchene
 * 
 */
public interface Task {

  /**
   * Getter for the conversaitonal object concerned with this task.
   * @return the conversational object owning this task
   */
  ConversationalObject getTaskOwner();

  /**
   * Stter for the conversaitonal object concerned with this task.
   * @param taskOwner the task owner to set.
   */
  void setTaskOwner(ConversationalObject taskOwner);

  /**
   * Getter for the status of this task
   * @return the current status of this task
   */
  TaskStatus getStatus();

  /**
   * Setter for the status of this task
   * @param status
   */
  void setStatus(TaskStatus status);

  /**
   * Getter for the stage of this task. It is strongly recomended that concrete
   * task classes declare static final string variables to refer to there
   * possible stages.
   * @return The current stage of this task
   */
  String getStage();

  /**
   * Getter for the result of this task.
   * @return the result of this task, or {@code null} if the task is not
   *         finished.
   */
  TaskResult getResult();

  /**
   * Getter for the set of tasks that depend from this task
   * @return The set of dependent tasks (can be null)
   */
  Set<Task> getDependentTasks();

  /**
   * Setter for the set of tasks that depend from this task
   * @param dependentTasks the set of dependent tasks to set
   */
  void setDependentTasks(Set<Task> dependentTasks);

  /**
   * Getter for the aggregated task this task has generated and is dependent on.
   * @return The aggregated task, if any (can be null)
   */
  Task getAggregatedTask();

  /**
   * Setter for the aggregated task this task has generated and is dependent on.
   * @param aggregatedTask the aggregated task to set
   */
  void setAggregatedTask(Task aggregatedTask);

  // TODO Other references could be added to extend the tasks model: e.g.
  // (1) subtasks: list of tasks composing this task, i.e. that should be
  // executed
  // in sequence in order to complete this task, and
  // (2) supertask: reversely, task this task is a subtask of.

  /**
   * Getter for the set of conversations this task generated and is now
   * dependent on.
   * @return the set of generated conversations
   */
  Set<OnGoingConversation> getGeneratedConversations();

  /**
   * Setter for generatedConversations.
   * @param generatedConversations the set of generatedConversations to set
   */
  void setGeneratedConversations(
      Set<OnGoingConversation> generatedConversations);

  /**
   * Cuts all references to other objects so that the garbage collector can
   * destroy them after having destroyed this task, if they are not referenced
   * by other objects than this task. Should be executed before removing the
   * last reference to this task (usually before removing this task from the set
   * of tasks of a conversational object)
   */
  void clean();

  /**
   * Executes the task. Specific to each concrete task class.
   */
  void execute();
}
